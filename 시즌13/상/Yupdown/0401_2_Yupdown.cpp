#include <bits/stdc++.h>
#define FASTIO() cin.tie(0),cout.tie(0),ios::sync_with_stdio(0)

// 흐즈로가 공을 던진 위치를 (0, 0)으로 하는 좌표계 기준으로 하였을 때, 흐즈로가 공을 던지는 궤적은
// - "흐즈로가 던진 공은 포물선 운동을 합니다"
// - "흐즈로가 공을 던지는 속도는 임의로 정할 수 있습니다"
// - "흐즈로가 공을 x축에 평행하게 던집니다"
// 위 세 가지의 조건에 의해 f(x) = -Gax^2 (G = 중력가속도, a = 임의의 양의 실수)로 나타낼 수 있다.
// 여기서는 편의를 위해 f(x) = -ax^2 로 정의하겠다. (임의의 실수에 상수가 곱해진 것은 선형 관계이기 때문에)

// 그렇다면, 어떤 과녁의 위치를 위의 좌표계 기준으로 나타내었을때의 좌표가 (x, y)일 때, 해당 위치 (x, y)를 지나는 f(x)를 생성하는 a는 유일함을 알 수 있다.
// 단, 이런 경우는 흐즈로가 과녁을 절대로 맞힐 수 없다.
// - y가 양수일 때. 즉, 과녁이 흐즈로보다 위에 있을 때.
// - y가 0일 때. 즉, 과녁이 흐즈로와 같은 x축 선상에 있을 때. 이런 경우 흐즈로는 무한의 속도로 공을 던저야 하므로 조건과 맞지 않는다.
// - y가 음수이나 x가 0일 때. 즉, 과녁이 흐즈로와 같은 y축 선상에 있을 때. 이런 경우 흐즈로는 0의 속도로 공을 던져야 하므로 조건과 맞지 않는다.
// 먼저 위의 경우를 체크하여 조건과 맞지 않을 경우 연산에서 제외하여야 한다.

// 위에서 구해진 a에 대해서 발상을 전환하면, "서로 다른 위치의 과녁들이 똑같은 a를 가지면, 그로 만들어진 포물선에 의해 한번에 맞춰질 수 있다"라는 뜻으로 나타낼 수 있다.
// 물론, 흐즈로는 포물선에 한쪽 방향만 공을 던질 수 있으므로, x의 부호를 고려하여 맞힐 수 있는 과녁을 구분하여야 한다.
// 어떤 방향과 a에서 가장 많이 맞힐 수 있는지 "memo[0][a] -> 왼쪽에서 맞힐 수 있는 과녁의 개수, memo[1][a] -> 오른쪽에서 맞힐 수 있는 과녁의 개수"의 꼴로
// 각 과녁에 대해 방향과 a를 구하여 카운팅을 수행한다.

// f(x)를 a에 대해 전개하면 a는 -y/x^2 의 꼴로 나타낼 수 있다.
// > a는 실수가 될 수도 있다. 배열을 이용한 카운팅 테이블을 만드는 대신에, std::map<double, int>으로 매핑하는 카운팅 테이블을 생각할 수 있다.
// > 하지만 이는 floating point error를 야기한다. 최대 2억이 될 수도 있는 x가 제곱으로 나뉘어지기 때문에 때문에 더욱 이 문제가 두드러지게 나타날 것이다.
// > 그래도 a는 유리수이기 때문에 num / den 의 분수 꼴로 나타낼 수 있다. (num, den)으로 나타낸 a를 std:map<std::pair<int64, int64>, int>으로 매핑하면 해결할 수 있다.
// > 여기서, (num, den)은 서로소여야 한다(기약분수의 꼴로 나타내어야 한다). 그래야 1/2과 2/4를 같은 키로 인식한다.
// > (num, den)을 서로소로 만들기 위해서는 num과 den 각각에 num과 den의 최대공약수를 나누면 된다.
// > c++17은 고맙게도 std::gcd(lhs, rhs)를 지원하기 때문에 이걸 사용하여 최대공약수를 구할 수 있다.

// 맞힐수 있는 모든 과녁에 대해 카운팅을 수행한 후, std::map의 value를 탐색하며 최대값을 구하면 된다.

using namespace std;
using int64 = long long;

map<pair<int64, int64>, int> memo[2];

int main()
{
	FASTIO();

	int64 x, y;
	int n;
	cin >> x >> y >> n;
	for (int i = 0; i < n; ++i)
	{
		int64 xi, yi;
		cin >> xi >> yi;
		if (yi >= y || xi == x)
			continue;
		int64 dx = xi - x;
		int64 dy = yi - y;
		int64 num = dy;
		int64 den = dx * dx;
		int64 g = gcd(num, den);
		num /= g;
		den /= g;
		memo[dx > 0][make_pair(num, den)]++;
	}
	int ret = 0;
	for (const auto& m : memo)
	{
		for (const auto& [k, v] : m)
			ret = max(ret, v);
	}
	cout << ret;
}